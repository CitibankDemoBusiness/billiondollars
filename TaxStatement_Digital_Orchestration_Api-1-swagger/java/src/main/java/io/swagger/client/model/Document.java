/*
 * TaxStatement_Digital_Orchestation
 * Account Documents APIs Version 2.0. These APIs will be used by Citi Partners to retrieve tax documents for existing Accounts from various regions. PCF Deployment Reference name --> DM-O-DocumentServices-Statements  </br>Version 2.0.0 Added new Tax statements apis.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * Document
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2023-08-14T16:47:58.241136Z[Etc/UTC]")
public class Document {
  @SerializedName("documentFormat")
  private String documentFormat = null;

  @SerializedName("encodeType")
  private String encodeType = null;

  @SerializedName("dataPayload")
  private String dataPayload = null;

  public Document documentFormat(String documentFormat) {
    this.documentFormat = documentFormat;
    return this;
  }

   /**
   * The format for the document.
   * @return documentFormat
  **/
  @Schema(example = "application/pdf", description = "The format for the document.")
  public String getDocumentFormat() {
    return documentFormat;
  }

  public void setDocumentFormat(String documentFormat) {
    this.documentFormat = documentFormat;
  }

  public Document encodeType(String encodeType) {
    this.encodeType = encodeType;
    return this;
  }

   /**
   * Image Encoding Type e.g. base16, base64
   * @return encodeType
  **/
  @Schema(example = "base64", description = "Image Encoding Type e.g. base16, base64")
  public String getEncodeType() {
    return encodeType;
  }

  public void setEncodeType(String encodeType) {
    this.encodeType = encodeType;
  }

  public Document dataPayload(String dataPayload) {
    this.dataPayload = dataPayload;
    return this;
  }

   /**
   * This field contains binary data for the statement.
   * @return dataPayload
  **/
  @Schema(example = "{\"encryptedPayload\":{\"header\":{\"alg\":\"RSA-OAEP\",\"enc\":\"A256KW\",\"kid\":\"Citi_2020-02-10\",\"x5c\":\"9f02dfd3143e8202d774793902ca07e888462d5e\",\"cty\":\"application/pdf\"},\"iv\":\"fBglurNNzOplKdjH\",\"ciphertext\":\"fBglurNNzOplKdjHXKCdSv4hQAAAAAAAAAAAAAA==\"}}", description = "This field contains binary data for the statement.")
  public String getDataPayload() {
    return dataPayload;
  }

  public void setDataPayload(String dataPayload) {
    this.dataPayload = dataPayload;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Document document = (Document) o;
    return Objects.equals(this.documentFormat, document.documentFormat) &&
        Objects.equals(this.encodeType, document.encodeType) &&
        Objects.equals(this.dataPayload, document.dataPayload);
  }

  @Override
  public int hashCode() {
    return Objects.hash(documentFormat, encodeType, dataPayload);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Document {\n");
    
    sb.append("    documentFormat: ").append(toIndentedString(documentFormat)).append("\n");
    sb.append("    encodeType: ").append(toIndentedString(encodeType)).append("\n");
    sb.append("    dataPayload: ").append(toIndentedString(dataPayload)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
